https://javarush.com/groups/posts/2253-znakomstvo-s-maven-spring-mysql-hibernate-i-pervoe-crud-prilozhenie-chastjh-1#Создание-проекта

1) Это будет веб-приложение, и мы будем использовать Tomcat.
Для развертывания (deploy) приложения в Tomcat нужно передать его туда в виде war архива
(Web Application Resource, специальный формат для веб-приложений). Для этого добавим в POM
файл такую строчку, чтобы приложение собиралось в war архив:
<packaging>war</packaging>

2) По-умолчанию Maven использует версию языка 1.5, но я хочу использовать, например, версию 1.8 – Java 8
(Можно и 10 взять, или 11, но все равно никакие фишки оттуда использовать не планируется, так что пускай 8 будет).
Решается это очень просто, пишем в гугле что-то вроде "Maven java 8" и смотрим что нужно добавить в POM файл.
!!! Взял инфо отсюда: https://maven.apache.org/plugins/maven-compiler-plugin/examples/set-compiler-source-and-target.html

3) Для создания веб приложения со Spring MVC нам также понадобится Servlet-API, т.е. та штука,
с помощью которой будет происходить взаимодействие запрос-ответ. Попробуем подключить это. Заходим в гугл,
ищем нужные зависимости в репозитории Maven и добавляем их в pom.xml.
!!! Подключил Spring-webmvc, javax.servlet-api
В разделе External Libraries видно, что подгрузилась не только spring-webmvc, но и куча чего еще.
Т.е. нам не нужно дополнительно подключать зависимости для spring core, context, beans и т.д. которые нам понадобятся,
все необходимое подтянулось само вместе со spring-webmvc.

Еще одно замечание. Что означает provided в зависимости javax.servlet-api.
Scope — это область действия зависимости, provided означает что зависимость будет доступна на этапе компиляции
и тестирования приложения, но в архив она помещена не будет. Дело в том, что для развертывания (deploy) приложения
мы будем использовать контейнер сервлетов, Tomcat, а у него внутри уже есть такие библиотеки, поэтому нет нужды
передавать их туда и утяжелять архив лишним грузом. Забегая вперед, по той же причине мы обойдемся без привычного
метода main, потому что он уже есть внутри Tomcat.

4) Для начала создадим в webapp дополнительную директорию, например pages,
в которой будут храниться наши представления (view), т.е. jsp-страницы, и создадим пару страниц.
!!! user, title

5) Добавим новый пакет controller и создадим в нем класс FilmController.

Что тут к чему. У Spring MVC есть такая штука, как DispatcherServlet.
Это как бы главный контроллер, все входящие запросы проходят через него и он уже дальше передает
их конкретному контроллеру. Аннотация @Controller как раз и сообщает Spring MVC, что данный класс
является контроллером (ну логично в общем-то), диспетчер будет проверять аннотации @RequestMapping
чтобы вызвать подходящий метод. Аннотация @RequestMapping позволяет задать адреса методам контроллера,
по которым они будут доступны в клиенте (браузер). Ее можно применять также и к классу контроллера,
чтобы задать, так сказать, корневой адрес для всех методов.
Для метода allFilms() параметр value установлен "/", поэтому он будет вызван сразу,
когда в браузере будет набрана комбинация http://host:port/
(т.е. по-умолчанию это http://localhost:8080/ или http://127.0.0.1:8080/).
Параметр method указывает кокой тип запроса поддерживается (GET, POST, PUT и т.д.).
Поскольку тут мы только получаем данные то используется GET.
Позднее, когда появятся методы для добавления и редактирования там уже будут POST запросы.
(Кстати вместо аннотации @RequestMapping с указанием метода,
можно использовать аннотации @GetMapping, @PostMapping и т.д.
@GetMapping эквивалентно @RequestMapping(method = RequestMethod.GET)).
В наших методах создаем объект ModelAndView и устанавливаем имя представления, которое нужно вернуть.

6) Создадим в пакете config класс WebConfig.
В нем будет только один метод возвращающий объект типа ViewResolver,
это такой интерфейс, необходимый для нахождения представления по имени.

---
@Configuration сообщает Spring что данный класс является конфигурационным и содержит определения
и зависимости bean-компонентов. Бины (bean) — это объекты, которые управляются Spring'ом.
Для определения бина используется аннотация @Bean.
---
@EnableWebMvc позволяет импортировать конфигурацию Spring MVC из класса WebMvcConfigurationSupport.
Можно также реализовать, например, интерфейс WebMvcConfigurer, у которого есть целая куча методов,
и настроить все по своему вкусу, но нам незачем пока в это углубляться, хватит и стандартных настроек.
---
@ComponentScan сообщает Spring где искать компоненты, которыми он должен управлять,
т.е. классы, помеченные аннотацией @Component или ее производными,
такими как @Controller, @Repository, @Service. Эти аннотации автоматически определяют бин класса.
---
В методе viewResolver() мы создаем его реализацию и определяем где именно искать представления в webapp.
Поэтому когда в методе контроллера мы устанавливали имя "user" представление найдется как "/pages/user.jsp"


7)Итак, класс конфигурации у нас есть, но пока что это просто какой-то отдельный класс,
он сам по себе и на наше приложение никак не влияет. Нам нужно зарегистрировать эту конфигурацию
в контексте Spring. Для этого нужен класс AbstractAnnotationConfigDispatcherServletInitializer.
В пакете config создаем его наследника, допустим AppConfig, и реализуем его методы.